<!--
    TTS Multi-Mode Reader - Cross-Platform (Mobile Enhanced)
    Web-based text-to-speech using device speech synthesis.
    Works on Windows, Mac, iOS, Android via Web Speech API.
    Single Voice: One voice with adjustable rate/pitch/volume.
    Conversation: Two alternating voices for dialog.
    
    MOBILE IMPROVEMENTS:
    - Manual voice loading trigger for mobile browsers
    - Smart fallback voice selection (works with Google TTS)
    - Better error handling and user feedback
    - Retry logic for voice loading
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTS Multi-Mode</title>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #1a1a2e;
            --bg-panel: rgba(26, 26, 46, 0.7);
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-danger: #ef4444;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0b0;
            --border-color: rgba(99, 102, 241, 0.3);
            --shadow-color: rgba(0, 0, 0, 0.5);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at top right, #1a1a2e 0%, #0a0a0f 50%, #16213e 100%);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0.75rem;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            text-align: center;
            padding: 0.75rem 1rem;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px var(--shadow-color);
            margin-bottom: 1rem;
        }

        header h1 {
            font-size: 1.75rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Mode Switcher */
        .mode-switcher {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .mode-btn {
            padding: 0.4rem 1.2rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .help-text {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 0.35rem;
            font-style: italic;
            min-height: 1rem;
        }

        /* Voice Loading Alert */
        .voice-alert {
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            display: none;
            align-items: center;
            gap: 0.5rem;
        }

        .voice-alert.show {
            display: flex;
        }

        .voice-alert.warning {
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid var(--accent-warning);
            color: var(--accent-warning);
        }

        .voice-alert.success {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid var(--accent-success);
            color: var(--accent-success);
        }

        .voice-alert button {
            margin-left: auto;
            padding: 0.35rem 0.75rem;
            background: var(--accent-warning);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Main Content */
        .main-content {
            display: flex;
            gap: 1rem;
            flex: 1;
            min-height: 0;
        }

        /* Text Panel */
        .text-panel {
            flex: 1;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1rem;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px var(--shadow-color);
            display: flex;
            flex-direction: column;
        }

        .text-panel h2 {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            color: var(--accent-primary);
        }

        #textInput {
            flex: 1;
            width: 100%;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: 'Consolas', 'Courier New', monospace;
            resize: none;
            transition: border-color 0.3s ease;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        #textInput::placeholder {
            color: var(--text-secondary);
        }

        /* Controls Panel */
        .controls-panel {
            width: 320px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1rem;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px var(--shadow-color);
            display: flex;
            flex-direction: column;
        }

        .controls-panel h2 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--accent-primary);
        }

        /* Voice Groups */
        .voice-group {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .voice-group h3 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--accent-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .voice-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .voice-a-indicator {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
        }

        .voice-b-indicator {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .voice-group select {
            width: 100%;
            padding: 0.65rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .voice-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .voice-group select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 0.65rem;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.35rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .slider-group label span {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5);
        }

        /* Buttons */
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: auto;
        }

        .btn {
            width: 100%;
            padding: 0.7rem;
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--glass-bg);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: var(--accent-primary);
        }

        .btn-primary:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            border-color: var(--text-secondary);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent-danger), #dc2626);
            border-color: var(--accent-danger);
        }

        .btn-danger:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }

            .controls-panel {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            header h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üéôÔ∏è TTS Multi-Mode</h1>
            <p class="subtitle">Single Voice & Conversation Reader</p>
            <div class="mode-switcher">
                <button class="mode-btn active" data-mode="single">Single Voice</button>
                <button class="mode-btn" data-mode="conversation">Conversation</button>
            </div>
            <p class="help-text" id="helpText">Enter any text to speak</p>

            <!-- Voice Loading Alert -->
            <div id="voiceAlert" class="voice-alert">
                <span id="voiceAlertText">Voices not loaded yet</span>
                <button id="loadVoicesBtn">Load Voices</button>
            </div>
        </header>

        <main class="main-content">
            <!-- Text Input Section -->
            <section class="text-panel">
                <h2>üìù Text Input</h2>
                <textarea id="textInput" placeholder="Enter text to speak...">Welcome to TTS Multi-Mode! This tool converts text to speech using your device's built-in voices. Try adjusting the rate, pitch, and volume controls to customize the experience. You can also switch to conversation mode to have two different voices alternate reading lines of dialogue.</textarea>
            </section>

            <!-- Voice Controls Section -->
            <section class="controls-panel">
                <h2>üéöÔ∏è Voice Controls</h2>

                <!-- Single Voice Mode Controls -->
                <div id="singleVoiceControls">
                    <div class="voice-group">
                        <h3>Voice</h3>
                        <select id="voiceSelectSingle">
                            <option>Loading voices...</option>
                        </select>
                    </div>

                    <div class="slider-group">
                        <label>Rate: <span id="rateValue">1.2</span></label>
                        <input type="range" id="rateSlider" min="0.5" max="2.0" step="0.1" value="1.2" class="slider">
                    </div>

                    <div class="slider-group">
                        <label>Pitch: <span id="pitchValue">1.0</span></label>
                        <input type="range" id="pitchSlider" min="0.5" max="2.0" step="0.1" value="1.0" class="slider">
                    </div>

                    <div class="slider-group">
                        <label>Volume: <span id="volumeValue">1.0</span></label>
                        <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1.0" class="slider">
                    </div>
                </div>

                <!-- Conversation Mode Controls -->
                <div id="conversationControls" class="hidden">
                    <div class="voice-group">
                        <h3><span class="voice-indicator voice-a-indicator"></span> Voice A</h3>
                        <select id="voiceSelectA">
                            <option>Loading voices...</option>
                        </select>
                    </div>

                    <div class="voice-group">
                        <h3><span class="voice-indicator voice-b-indicator"></span> Voice B</h3>
                        <select id="voiceSelectB">
                            <option>Loading voices...</option>
                        </select>
                    </div>

                    <div class="slider-group">
                        <label>Rate: <span id="rateValueConv">1.2</span></label>
                        <input type="range" id="rateSliderConv" min="0.5" max="2.0" step="0.1" value="1.2"
                            class="slider">
                    </div>

                    <div class="slider-group">
                        <label>Pitch: <span id="pitchValueConv">1.0</span></label>
                        <input type="range" id="pitchSliderConv" min="0.5" max="2.0" step="0.1" value="1.0"
                            class="slider">
                    </div>

                    <div class="slider-group">
                        <label>Volume: <span id="volumeValueConv">1.0</span></label>
                        <input type="range" id="volumeSliderConv" min="0" max="1" step="0.1" value="1.0" class="slider">
                    </div>
                </div>

                <div class="button-group">
                    <button id="playBtn" class="btn btn-primary">
                        <span>‚ñ∂Ô∏è Play</span>
                    </button>
                    <button id="pauseBtn" class="btn btn-secondary" disabled>
                        <span>‚è∏Ô∏è Pause</span>
                    </button>
                    <button id="stopBtn" class="btn btn-danger" disabled>
                        <span>‚èπÔ∏è Stop</span>
                    </button>
                </div>
            </section>
        </main>
    </div>

    <script>
        // TTS Multi-Mode - Mobile Enhanced
        // Improved voice loading for mobile browsers

        class TTSMultiMode {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voices = [];
                this.isPaused = false;
                this.currentMode = 'single';
                this.dialogParts = [];
                this.currentPartIndex = 0;
                this.nextQueued = false;
                this.textChunks = [];
                this.currentChunkIndex = 0;
                this.voicesLoaded = false;
                this.voiceLoadAttempts = 0;
                this.maxVoiceLoadAttempts = 3;

                // DOM Elements
                this.textInput = document.getElementById('textInput');
                this.helpText = document.getElementById('helpText');
                this.voiceAlert = document.getElementById('voiceAlert');
                this.voiceAlertText = document.getElementById('voiceAlertText');
                this.loadVoicesBtn = document.getElementById('loadVoicesBtn');
                this.voiceSelectSingle = document.getElementById('voiceSelectSingle');
                this.voiceSelectA = document.getElementById('voiceSelectA');
                this.voiceSelectB = document.getElementById('voiceSelectB');
                this.rateSlider = document.getElementById('rateSlider');
                this.pitchSlider = document.getElementById('pitchSlider');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.rateValue = document.getElementById('rateValue');
                this.pitchValue = document.getElementById('pitchValue');
                this.volumeValue = document.getElementById('volumeValue');
                this.rateSliderConv = document.getElementById('rateSliderConv');
                this.pitchSliderConv = document.getElementById('pitchSliderConv');
                this.volumeSliderConv = document.getElementById('volumeSliderConv');
                this.rateValueConv = document.getElementById('rateValueConv');
                this.pitchValueConv = document.getElementById('pitchValueConv');
                this.volumeValueConv = document.getElementById('volumeValueConv');
                this.playBtn = document.getElementById('playBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.singleVoiceControls = document.getElementById('singleVoiceControls');
                this.conversationControls = document.getElementById('conversationControls');

                this.init();
            }

            init() {
                console.log('üîä TTS Multi-Mode Initializing...');
                console.log('üì± User Agent:', navigator.userAgent);

                // Try to load voices immediately
                this.attemptLoadVoices();

                // Voice loading event (primary method for most browsers)
                if (this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => {
                        console.log('üîÑ onvoiceschanged event fired');
                        this.attemptLoadVoices();
                    };
                }

                // Retry loading after delays (mobile browsers may need this)
                setTimeout(() => this.attemptLoadVoices(), 500);
                setTimeout(() => this.attemptLoadVoices(), 1500);
                setTimeout(() => this.attemptLoadVoices(), 3000);

                // Event listeners
                this.setupEventListeners();

                this.updateStatus('Ready');
            }

            attemptLoadVoices() {
                this.voiceLoadAttempts++;
                console.log(`üîÑ Voice load attempt #${this.voiceLoadAttempts}`);

                const voices = this.synth.getVoices();
                console.log(`üìã Found ${voices.length} voices`);

                if (voices.length > 0 && !this.voicesLoaded) {
                    this.voices = voices;
                    this.voicesLoaded = true;

                    // Log available voices for debugging
                    console.log('‚úÖ Voices loaded:', voices.map(v => `${v.name} (${v.lang})`));

                    this.populateVoiceLists();
                    this.showVoiceSuccess();
                } else if (this.voiceLoadAttempts >= this.maxVoiceLoadAttempts && voices.length === 0) {
                    // Show manual load button after max attempts
                    this.showVoiceLoadPrompt();
                }
            }

            manualLoadVoices() {
                console.log('üëÜ Manual voice load triggered');

                // Trigger a dummy utterance to wake up mobile voice engine
                const utterance = new SpeechSynthesisUtterance('');
                this.synth.speak(utterance);
                this.synth.cancel();

                // Try loading again
                setTimeout(() => {
                    this.attemptLoadVoices();

                    // If still no voices, show error
                    if (this.voices.length === 0) {
                        this.voiceAlertText.textContent = '‚ö†Ô∏è No voices available. Try refreshing the page.';
                        this.loadVoicesBtn.style.display = 'none';
                    }
                }, 300);
            }

            showVoiceLoadPrompt() {
                this.voiceAlert.classList.add('show', 'warning');
                this.voiceAlertText.textContent = '‚ö†Ô∏è Voice picker unavailable, but speech still works';
            }

            showVoiceSuccess() {
                this.voiceAlert.classList.remove('warning');
                this.voiceAlert.classList.add('show', 'success');
                this.voiceAlertText.textContent = `‚úÖ ${this.voices.length} voices loaded`;
                this.loadVoicesBtn.style.display = 'none';

                // Hide success message after 3 seconds
                setTimeout(() => {
                    this.voiceAlert.classList.remove('show');
                }, 3000);
            }

            populateVoiceLists() {
                // Filter en-US voices (fallback to en- if no en-US found)
                let enUSVoices = this.voices.filter(voice => voice.lang.startsWith('en-US'));

                if (enUSVoices.length === 0) {
                    console.log('‚ö†Ô∏è No en-US voices found, using all en- voices');
                    enUSVoices = this.voices.filter(voice => voice.lang.startsWith('en-'));
                }

                if (enUSVoices.length === 0) {
                    console.log('‚ö†Ô∏è No English voices found, using all voices');
                    enUSVoices = this.voices;
                }

                console.log(`üìã Filtered to ${enUSVoices.length} English voices`);

                // Populate single voice selector
                this.voiceSelectSingle.innerHTML = '';
                enUSVoices.forEach((voice) => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.value = this.voices.indexOf(voice);
                    this.voiceSelectSingle.appendChild(option);
                });

                // Populate conversation selectors
                this.voiceSelectA.innerHTML = '';
                this.voiceSelectB.innerHTML = '';
                enUSVoices.forEach((voice) => {
                    const optionA = document.createElement('option');
                    optionA.textContent = `${voice.name} (${voice.lang})`;
                    optionA.value = this.voices.indexOf(voice);
                    this.voiceSelectA.appendChild(optionA);

                    const optionB = document.createElement('option');
                    optionB.textContent = `${voice.name} (${voice.lang})`;
                    optionB.value = this.voices.indexOf(voice);
                    this.voiceSelectB.appendChild(optionB);
                });

                // Auto-select voices with smart fallbacks
                this.autoSelectVoices();
            }

            autoSelectVoices() {
                // Preferred voice patterns (in order of preference)
                const preferredPatternsA = [
                    /andrew/i,           // Windows Andrew
                    /male.*us/i,         // Any US male voice
                    /\bmale\b/i,         // Any male voice
                    /google us english/i // Google US English (typically male on Android)
                ];

                const preferredPatternsB = [
                    /jenny/i,            // Windows Jenny
                    /female.*us/i,       // Any US female voice
                    /\bfemale\b/i,       // Any female voice
                    /samantha/i          // macOS Samantha
                ];

                // Find Voice A
                let voiceAIndex = -1;
                for (const pattern of preferredPatternsA) {
                    voiceAIndex = this.voices.findIndex(voice => {
                        const match = pattern.test(voice.name);
                        const notMultilingual = !voice.name.toLowerCase().includes('multilingual');
                        return match && notMultilingual;
                    });
                    if (voiceAIndex !== -1) {
                        console.log(`‚úÖ Voice A selected: ${this.voices[voiceAIndex].name} (matched ${pattern})`);
                        break;
                    }
                }

                // Find Voice B
                let voiceBIndex = -1;
                for (const pattern of preferredPatternsB) {
                    voiceBIndex = this.voices.findIndex(voice => {
                        const match = pattern.test(voice.name);
                        const notMultilingual = !voice.name.toLowerCase().includes('multilingual');
                        return match && notMultilingual;
                    });
                    if (voiceBIndex !== -1) {
                        console.log(`‚úÖ Voice B selected: ${this.voices[voiceBIndex].name} (matched ${pattern})`);
                        break;
                    }
                }

                // Fallback: Use first two different voices if specific ones not found
                if (voiceAIndex === -1 && this.voices.length > 0) {
                    voiceAIndex = 0;
                    console.log(`‚ö†Ô∏è Voice A fallback: ${this.voices[voiceAIndex].name}`);
                }

                if (voiceBIndex === -1 && this.voices.length > 1) {
                    voiceBIndex = 1;
                    console.log(`‚ö†Ô∏è Voice B fallback: ${this.voices[voiceBIndex].name}`);
                } else if (voiceBIndex === -1 && this.voices.length === 1) {
                    voiceBIndex = 0; // Same voice if only one available
                    console.log(`‚ö†Ô∏è Voice B fallback (same as A): ${this.voices[voiceBIndex].name}`);
                }

                // Apply selections
                if (voiceAIndex !== -1) {
                    this.voiceSelectSingle.value = voiceAIndex;
                    this.voiceSelectA.value = voiceAIndex;
                }

                if (voiceBIndex !== -1) {
                    this.voiceSelectB.value = voiceBIndex;
                }
            }

            setupEventListeners() {
                // Manual voice loading button
                this.loadVoicesBtn.addEventListener('click', () => this.manualLoadVoices());

                // Mode switcher
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mode = e.target.dataset.mode;
                        this.switchMode(mode);
                    });
                });

                // Slider updates - Single mode
                this.rateSlider.addEventListener('input', (e) => {
                    this.rateValue.textContent = e.target.value;
                });

                this.pitchSlider.addEventListener('input', (e) => {
                    this.pitchValue.textContent = e.target.value;
                });

                this.volumeSlider.addEventListener('input', (e) => {
                    this.volumeValue.textContent = e.target.value;
                });

                // Slider updates - Conversation mode
                this.rateSliderConv.addEventListener('input', (e) => {
                    this.rateValueConv.textContent = e.target.value;
                });

                this.pitchSliderConv.addEventListener('input', (e) => {
                    this.pitchValueConv.textContent = e.target.value;
                });

                this.volumeSliderConv.addEventListener('input', (e) => {
                    this.volumeValueConv.textContent = e.target.value;
                });

                // Playback controls
                this.playBtn.addEventListener('click', () => this.play());
                this.pauseBtn.addEventListener('click', () => this.pause());
                this.stopBtn.addEventListener('click', () => this.stop());
            }

            switchMode(mode) {
                this.currentMode = mode;

                // Update UI
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });

                if (mode === 'single') {
                    this.singleVoiceControls.classList.remove('hidden');
                    this.conversationControls.classList.add('hidden');
                    this.helpText.textContent = 'Enter any text to speak';
                    this.textInput.placeholder = 'Enter text to speak...';
                } else {
                    this.singleVoiceControls.classList.add('hidden');
                    this.conversationControls.classList.remove('hidden');
                    this.helpText.textContent = 'Format: "A: dialog text" or "B: dialog text" on separate lines';
                    this.textInput.placeholder = 'A: Hello! How are you today?\nB: I\'m doing great, thanks for asking!\nA: That\'s wonderful to hear.';
                }

                // Stop any current playback
                this.stop();
            }

            play() {
                const text = this.textInput.value.trim();

                if (!text) {
                    this.updateStatus('Error: Please enter text');
                    return;
                }

                // If paused, resume
                if (this.isPaused) {
                    this.synth.resume();
                    this.isPaused = false;
                    this.updateStatus('Resumed');
                    this.pauseBtn.disabled = false;
                    this.stopBtn.disabled = false;
                    this.playBtn.disabled = true;
                    return;
                }

                // Stop any current speech
                this.synth.cancel();

                // Play based on mode
                if (this.currentMode === 'single') {
                    this.playSingleVoice(text);
                } else {
                    this.playConversation(text);
                }

                // Update button states
                this.playBtn.disabled = true;
                this.pauseBtn.disabled = false;
                this.stopBtn.disabled = false;
            }

            playSingleVoice(text) {
                // Split into chunks
                this.textChunks = this.splitTextIntoChunks(text);
                this.currentChunkIndex = 0;

                this.updateStatus(`Speaking (${this.textChunks.length} chunks)...`);
                this.speakNextChunk();
            }

            splitTextIntoChunks(text, maxLength = 4000) {
                const sentences = text.match(/[^.!?]+[.!?]+[\s]*/g) || [text];
                const chunks = [];
                let currentChunk = '';

                sentences.forEach(sentence => {
                    const trimmedSentence = sentence.trim();

                    if (trimmedSentence.length > maxLength) {
                        if (currentChunk.length > 0) {
                            chunks.push(currentChunk.trim());
                            currentChunk = '';
                        }

                        let remainingText = trimmedSentence;
                        while (remainingText.length > maxLength) {
                            let splitIndex = remainingText.lastIndexOf(' ', maxLength);
                            if (splitIndex === -1) splitIndex = maxLength;

                            chunks.push(remainingText.substring(0, splitIndex).trim());
                            remainingText = remainingText.substring(splitIndex).trim();
                        }

                        if (remainingText.length > 0) {
                            chunks.push(remainingText);
                        }
                        return;
                    }

                    if (currentChunk.length + trimmedSentence.length + 1 > maxLength && currentChunk.length > 0) {
                        chunks.push(currentChunk.trim());
                        currentChunk = trimmedSentence;
                    } else {
                        currentChunk += (currentChunk.length > 0 ? ' ' : '') + trimmedSentence;
                    }
                });

                if (currentChunk.trim().length > 0) {
                    chunks.push(currentChunk.trim());
                }

                return chunks.length > 0 ? chunks : [text];
            }

            speakNextChunk() {
                if (this.currentChunkIndex >= this.textChunks.length) {
                    this.onSpeechEnd();
                    return;
                }

                const chunk = this.textChunks[this.currentChunkIndex];
                const utterance = new SpeechSynthesisUtterance(chunk);

                // Use selected voice if available, otherwise browser will use default
                const voiceIndex = parseInt(this.voiceSelectSingle.value);
                if (this.voices.length > 0 && this.voices[voiceIndex]) {
                    utterance.voice = this.voices[voiceIndex];
                }
                // Browser will use default voice if none specified

                utterance.rate = parseFloat(this.rateSlider.value);
                utterance.pitch = parseFloat(this.pitchSlider.value);
                utterance.volume = parseFloat(this.volumeSlider.value);

                utterance.onend = () => {
                    this.currentChunkIndex++;
                    this.updateStatus(`Speaking chunk ${this.currentChunkIndex}/${this.textChunks.length}...`);
                    setTimeout(() => this.speakNextChunk(), 50);
                };

                utterance.onerror = (event) => {
                    console.error('Speech error:', event);
                    this.updateStatus(`Error: ${event.error}`);
                    this.onSpeechEnd();
                };

                this.synth.speak(utterance);
            }

            playConversation(text) {
                this.dialogParts = this.parseDialog(text);

                if (this.dialogParts.length === 0) {
                    this.updateStatus('Error: No valid dialog found. Use "A: text" or "B: text" format');
                    this.onSpeechEnd();
                    return;
                }

                this.currentPartIndex = 0;
                this.nextQueued = false;

                const speakerACount = this.dialogParts.filter(p => p.speaker === 'A').length;
                const speakerBCount = this.dialogParts.filter(p => p.speaker === 'B').length;

                this.updateStatus(`Playing conversation (${this.dialogParts.length} lines: A√ó${speakerACount}, B√ó${speakerBCount})`);
                this.speakNextPart();
            }

            parseDialog(text) {
                const lines = text.split('\n').filter(line => line.trim().length > 0);
                const dialogParts = [];

                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    const colonMatch = trimmedLine.match(/^([AB]):\s*(.+)$/i);
                    const bracketMatch = trimmedLine.match(/^\[([AB])\]\s*(.+)$/i);

                    if (colonMatch) {
                        dialogParts.push({
                            speaker: colonMatch[1].toUpperCase(),
                            text: colonMatch[2].trim()
                        });
                    } else if (bracketMatch) {
                        dialogParts.push({
                            speaker: bracketMatch[1].toUpperCase(),
                            text: bracketMatch[2].trim()
                        });
                    } else if (trimmedLine.length > 0) {
                        const lastSpeaker = dialogParts.length > 0
                            ? dialogParts[dialogParts.length - 1].speaker
                            : 'A';
                        dialogParts.push({
                            speaker: lastSpeaker,
                            text: trimmedLine
                        });
                    }
                });

                return dialogParts;
            }

            speakNextPart() {
                if (this.currentPartIndex >= this.dialogParts.length) {
                    this.onSpeechEnd();
                    return;
                }

                const part = this.dialogParts[this.currentPartIndex];
                const utterance = new SpeechSynthesisUtterance(part.text);

                // Use selected voice if available, otherwise browser will use default
                const voiceIndex = part.speaker === 'A'
                    ? parseInt(this.voiceSelectA.value)
                    : parseInt(this.voiceSelectB.value);

                if (this.voices.length > 0 && this.voices[voiceIndex]) {
                    utterance.voice = this.voices[voiceIndex];
                }
                // Browser will use default voice if none specified

                utterance.rate = parseFloat(this.rateSliderConv.value);
                utterance.pitch = parseFloat(this.pitchSliderConv.value);
                utterance.volume = parseFloat(this.volumeSliderConv.value);

                let nextQueued = false;
                const partIndex = this.currentPartIndex;

                utterance.onstart = () => {
                    this.updateStatus(`Speaking [${part.speaker}]: "${part.text.substring(0, 40)}${part.text.length > 40 ? '...' : ''}" (${partIndex + 1}/${this.dialogParts.length})`);
                };

                utterance.onboundary = (event) => {
                    if (!nextQueued && event.name === 'word') {
                        const remainingChars = part.text.length - event.charIndex;
                        if (remainingChars < 100 && remainingChars > 0) {
                            nextQueued = true;
                            this.currentPartIndex++;
                            this.speakNextPart();
                        }
                    }
                };

                utterance.onend = () => {
                    if (!nextQueued) {
                        this.currentPartIndex++;
                        this.speakNextPart();
                    }
                };

                utterance.onerror = (event) => {
                    console.error('Speech error:', event);
                    this.updateStatus(`Error: ${event.error}`);
                    this.onSpeechEnd();
                };

                this.synth.speak(utterance);
            }

            pause() {
                if (this.synth.speaking && !this.isPaused) {
                    this.synth.pause();
                    this.isPaused = true;
                    this.updateStatus('Paused');
                    this.playBtn.disabled = false;
                    this.pauseBtn.disabled = true;
                }
            }

            stop() {
                this.synth.cancel();
                this.isPaused = false;
                this.currentPartIndex = 0;
                this.dialogParts = [];
                this.nextQueued = false;
                this.textChunks = [];
                this.currentChunkIndex = 0;
                this.onSpeechEnd();
            }

            onSpeechEnd() {
                this.updateStatus('Ready');
                this.playBtn.disabled = false;
                this.pauseBtn.disabled = true;
                this.stopBtn.disabled = true;
                this.isPaused = false;
            }

            updateStatus(message) {
                // Status logging (console only)
                console.log(`üìä Status: ${message}`);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            new TTSMultiMode();
        });
    </script>
</body>

</html>